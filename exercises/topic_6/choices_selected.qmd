{{< include ../../_extensions/r-wasm/live/_knitr.qmd >}}

## Topic 6: Deeper dive into customizing the parameters of `teal.modules.clinical` modules (10 minutes)

The `choices_selected` function from `teal.transform` is a powerful utility for managing variable selections in teal modules.
It provides a flexible way to specify choices and default selections for inputs, with support for both eager and delayed evaluation.

This topic will cover common scenarios app developers face when building teal applications from existing modules:
- Limiting variable choices in module inputs
- Providing choices without knowing the dataset structure upfront
- Adapting to different datasets dynamically

## Introduction to `choices_selected`

### Basic Usage

> The `choices_selected` function creates an object that specifies both available choices and selected defaults for UI inputs.

The choices can be provided in two ways:

- Statically as character vectors
- Dynamically by referencing the dataset _(when using within a teal application that does not yet know the full data structure)_.

```{webr message=FALSE, warning=FALSE}
library(teal.transform)

choices_selected(c("ARM", "ARMCD"), "ARM") # Static

ADSL <- pharmaverseadam::adsl
choices_selected(variable_choices(ADSL, c("ARM", "ARMCD")), "ARM") # Data-dependent

choices_selected(variable_choices("ADSL", c("ARM", "ARMCD")), "ARM") # Data-dependent and delayed
```

### `teal` example with clinical module

Let's start with a basic teal application that uses `choices_selected`:

```{.r}
library(teal.modules.clinical)

# Create sample data
data <- teal_data() |>
  within({
    ADSL <- pharmaverseadam::adsl

    ADSL$ARM <- as.factor(ADSL$ARM)
    ADSL$ARMCD <- as.factor(ADSL$ARMCD)
    ADSL$SEX <- as.factor(ADSL$SEX)
    ADSL$RACE <- as.factor(ADSL$RACE)

    attr(ADSL$ARM, "label") <- "Actual Treatment Arm"
    attr(ADSL$ARMCD, "label") <- "Actual Treatment Arm Code"
    attr(ADSL$SEX, "label") <- "Sex"
    attr(ADSL$RACE, "label") <- "Race"
})

join_keys(data) <- default_cdisc_join_keys[names(data)]

# Basic application using choices_selected
app <- init(
  data = data,
  modules = modules(
    tm_t_summary(
      label = "Demographic Table",
      dataname = "ADSL",
      arm_var = choices_selected(c("ARM", "ARMCD"), "ARM"),
      add_total = TRUE,
      summarize_vars = choices_selected(
        c("SEX", "RACE", "AGE"),
        selected = c("SEX", "RACE", "AGE")
      ),
      useNA = "ifany"
    )
  )
)

runApp(app)
```

## Using `value_choices`

> The `value_choices` function retrieves the actual choices from a dataset based on variable names.

- Requires a dataset to extract the values from specified columns
  - Dataset can be provided directly or as a reference to be resolved later
- When multiple columns are provided: it combines unique values from all specified columns

```{webr}
library(pharmaverseadam)
# Basic choices_selected example
ADSL <- pharmaverseadam::adsl

value_choices(ADSL, c("ARMCD"), c("ARM"))

choices_selected(value_choices(ADSL, c("ARMCD"), c("ARM")))
```

## Using `variable_choices`

> The `variable_choices` function allows you to dynamically select variables based on dataset characteristics.

```{webr}
numeric_vars <- variable_choices(ADSL, subset = function(data) {
  idx <- vapply(data, is.numeric, logical(1))
  names(data)[idx]
})

# Use with choices_selected
analysis_vars <- choices_selected(
  choices = numeric_vars,
  selected = variable_choices(ADSL, subset = function(data) {
    names(data)[names(data) %in% c("AGE", "TRTDURD")]
  })
)

analysis_vars
```

### Eager evaluation vs. Delayed evaluation

The `variable_choices` function can be used in two modes:

- Eager evaluation computes choices immediately, allowing for inspecting the choices beforehand _(just as shown above)_.
- Delayed evaluation allows choices to be determined at runtime, which is useful when dataset structure isn't known beforehand _(see example below)_.

```{webr}
factor_vars <- variable_choices("ADSL", subset = function(data) {
  colnames(data)[is.factor(data)]
})

# Use with choices_selected
analysis_vars <- choices_selected(
  choices = factor_vars,
  selected = variable_choices("ADSL", subset = function(data) {
    names(data)[names(data) %in% c("SEX", "RACE", "AGE")]
  })
)

print(analysis_vars)
```

#### Application with Dynamic Variable Selection

```{.r}
# Application that automatically finds numeric variables
app_dynamic <- init(
  data = data,
  modules = modules(
    tm_t_summary(
      label = "Demographic Table",
      dataname = "ADSL",
      arm_var = choices_selected(c("ARM", "ARMCD"), "ARM"),
      add_total = TRUE,
      summarize_vars = analysis_vars,
      useNA = "ifany"
    )
  )
)

runApp(app_dynamic)
```

### `teal` example with Kaplan-Meier module

Using Kaplan-Meier module from `teal.modules.clinical`

```{.r}
{{< include support_km.R >}}
```

::: {.callout-tip collapse="true"}
### Example App

```{shinylive-r}
#| standalone: true
#| viewerHeight: 680
{{< include support_km.R >}}
```

:::


## üõ†Ô∏è Exercise

Fill in the code below to create a teal application that uses `choices_selected` to limit the variable choices for a summary table module.

- `group_var` with Treatment variable,
- `y` with Analysis variable,
- `param` with Parameter of Interest


```{.r}
{{< include exercise_6.R >}}
```

::: {.callout-tip collapse="true"}
### Answer

```{.r}
{{< include solution_exercise_6.R >}}
```
:::

## üìö What did we learn?

The `choices_selected` and `value_choices` functions provides powerful flexibility for managing variable and value selections in teal applications.
By combining it with `variable_choices` and understanding when to use eager vs. delayed evaluation, you can create robust applications that adapt to different datasets and provide users with appropriate choices.

Key takeaways:
- Use `variable_choices` with subset functions for dynamic filtering
- Delayed evaluation helps when dataset structure is unknown
  - Important with `teal_data_modules`
- Smart defaults improve user experience across different datasets

### üí≠ What did we not cover?

`data_extract_spec` is the underlying specification that powers `choices_selected` in the modules.
It provides a more general framework for defining choices and selections, and can be customized further for advanced use cases.

The `data_extract_ui` and `data_extract_srv` functions can be used in modules to create custom UI and server logic for data extraction based on `data_extract_spec` and `choices_selected` _(via `teal.modules.clinical::cs_to_des_select`)_.

Useful links for further exploration:

- [`data_extract_spec` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/data_extract_spec.html)
- [`cs_to_des_select` documentation](https://insightsengineering.github.io/teal.modules.clinical/latest-tag/reference/cs_to_des_select.html)
- [`data_extract_ui` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/data_extract_ui.html)
- [`data_extract_srv` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/data_extract_srv.html)

## üåê References

- [`choices_selected()` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/choices_selected.html)
- [`value_choices()` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/value_choices.html)
- [`variable_choices()` documentation](https://insightsengineering.github.io/teal.transform/latest-tag/reference/variable_choices.html)

